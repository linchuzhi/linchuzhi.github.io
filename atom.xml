<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沈小洋的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenofusc.github.com/"/>
  <updated>2020-11-18T12:15:34.459Z</updated>
  <id>http://shenofusc.github.com/</id>
  
  <author>
    <name>沈小洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring嵌套事务机制补充</title>
    <link href="http://shenofusc.github.com/2020/11/15/spring-propagation-nested-more/"/>
    <id>http://shenofusc.github.com/2020/11/15/spring-propagation-nested-more/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-18T12:15:34.459Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://shenofusc.github.io/2019/04/20/spring-propagation-nested" target="_blank" rel="noopener">文章</a>，是关于Spring嵌套事务机制的，回过头来看发现有不少问题，但暂时不想删掉它，所以再写一篇文章更正一下之前的错误。这里先再次说明一下PROPAGATION_NESTED的作用，若当前存在事务则以嵌套事务方式执行，若不存在事务则创建一个新事务。</p><p>考虑到动态代理的实现方式，同一个类内部不同方法之间的调用只有外部方法的代理会生效，因此这里的讨论不考虑同一个类内部方法之间互相调用的情况，只考虑不同的类之间的方法进行调用的情况。</p><p>我们知道嵌套事务底层实际是利用SAVEPOINT实现的，因此外部事务回滚必然会导致整个事务回滚。若外部没有事务，则内部事务是否回滚取决于内部代码。这里假设调用方法叫ServiceA，被调用方法叫ServiceB。A上面标注的是PROPAGATION_REQUIRED，B上面标注的是PROPAGATION_NESTED。假设现在代码发生了异常，异常发生的位置存在三种情况：①发生在A处、②发生在B处、③两处都发生了异常。</p><p>若是情况①，内部事务包含在外部事务中，因此内外部的事务都会回滚。</p><p>若是情况②，还得再细分为两种情况，即A里面是否忽略B的异常，若A忽略B产生的异常，则内部事务回滚，外部事务正常提交。若A将B的异常继续往上抛出，则内外部事务都会回滚。</p><p>若是情况③，那自然不用多解释，内外部事务必然都会回滚。</p><p>可能出现的情况大概就这么几种，使用起来其实也不复杂，知道这几个小细节用起来就不会出错了。</p><p>再补充几点使用Spring事务的细节吧。之前做过一些实验，正好一起记录一下。主要有三点：使用声明式事务的注意事项、内部调用的事务生效情况、跨类调用的事务生效情况。</p><p>使用声明式事务时，无论是JDK动态代理，还是CGLIB动态代理，都只会为public方法生成事务，因此给非public方法加@Transactional注解是不生效的。Spring之所以这样实现，个人理解可能是为了避免引入不必要的复杂度，因为理论上动态代理也是可以代理非public方法的。</p><p>调用代理类中的非事务方法时，即使该方法内部调用了代理类中其他的事务方法，内部方法的事务也是不会生效的。因为Spring同时维护了目标对象和代理对象，不需要增强的方法Spring会直接走目标对象，所以这种方式下事务就不生效了。</p><p>跨类调用时，若外部方法未开启事务则外部方法中的数据不会回滚，内部方法则由该方法的事务配置决定。若外部方法开启事务，默认配置下内外部方法都会存在事务，除非自定义了事务传播属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://shenofusc.github.io/2019/04/20/spring-propagation-nested&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，是关于Spring嵌套事务机制的，回过头来
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://shenofusc.github.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring嵌套事务机制</title>
    <link href="http://shenofusc.github.com/2019/04/20/spring-propagation-nested/"/>
    <id>http://shenofusc.github.com/2019/04/20/spring-propagation-nested/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2020-11-15T09:21:57.637Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的几种事务传播机制如下:</p><p>PROPAGATION_REQUIRED:Support a current transaction, create a new one if none exists.<br>PROPAGATION_SUPPORTS:Support a current transaction, execute non-transactionally if none exists.<br>PROPAGATION_MANDATORY:Support a current transaction, throw an exception if none exists.<br>PROPAGATION_REQUIRES_NEW:Create a new transaction, and suspend the current transaction if one exists.<br>PROPAGATION_NOT_SUPPORTED:Execute non-transactionally, suspend the current transaction if one exists.<br>PROPAGATION_NEVER:Execute non-transactionally, throw an exception if a transaction exists.<br>PROPAGATION_NESTED:Execute within a nested transaction if a current transaction exists, behave like PROPAGATION_REQUIRED.</p><p>这里的英文注释是直接从源码里贴过来的，我感觉已经描述的非常简洁明了了。这里主要记录下最后一种: PROPAGATION_NESTED 。主要通过以下几个问题来说明下它的机制，问题如下：  </p><p>1.如果子事务回滚，会发生什么？</p><p>我自己做了下实验，发现如果子事务回滚的话，不仅子事务本身会回滚，父事务同样会回滚。</p><blockquote><p>而且实验过程中还发现了一个有意思的东西，如果数据库的主键设置为自增的话，那些没有提交的事务依然会占用自增ID，导致ID跳号。例如测试前的最后一条数据ID为 1 ，一次插入操作回滚后再执行另一次成功的插入，最新的ID会是 3 。</p></blockquote><p>2.如果父事务回滚，会发生什么？</p><p>父事务回滚的情况和 PROPAGATION_REQUIRED 模式下没什么区别，子事务和父事务都会回滚。</p><p>3.出现异常的话会发生什么？</p><p>假设现在是 ServiceA 方法调用 ServiceB 方法，ServiceA 的传播级别为 PROPAGATION_REQUIRED，ServiceB 的传播级别为 PROPAGATION_NESTED，在出现异常的情况下，只要能够吃掉异常，不管是哪个方法的异常，事务就能够正常提交。如果不处理异常的话，不管是 ServiceA 出现异常还是 ServiceB 出现异常，内外层事务都会回滚。很多文章都提到了一个关键字：savepoint，这是一个很特别的东西，在进入 ServiceB 之前，会保存 ServiceA 当前的执行状态到 savepoint，如果 ServiceB 执行过程中出现异常的话，会回滚到 savepoint 所在的状态。但是这里有一个坑，首先，你必须得在 ServiceA 中捕获到异常并且吃掉它，否则 ServiceA 照样回滚，savepoint？不存在的。其次，如果你是在同一个对象中调用不同的方法的话，savepoint 依然是没有的。只有在不同的对象之间进行调用，才会保存 ServiceA 的执行状态到 savepoint ，ServiceB 的事务回滚时才能恢复到 savepoint 所在的状态。</p><p>总结一下的话就是这个地方的状态组合超多，稍有不慎就是个大坑，不是很必要的情况下还是老老实实用默认的 PROPAGATION_REQUIRED 比较好。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.im/post/5a3b1dc4f265da43333e9049" target="_blank" rel="noopener">Spring事务机制详解</a></p><p><a href="https://blog.csdn.net/ID19870510/article/details/78884130" target="_blank" rel="noopener">Spring事务传播机制-REQUIRED嵌套NESTED</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring的几种事务传播机制如下:&lt;/p&gt;
&lt;p&gt;PROPAGATION_REQUIRED:Support a current transaction, create a new one if none exists.&lt;br&gt;PROPAGATION_SUPPORTS:Su
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://shenofusc.github.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://shenofusc.github.com/2017/08/19/singleton-pattern/"/>
    <id>http://shenofusc.github.com/2017/08/19/singleton-pattern/</id>
    <published>2017-08-18T16:00:00.000Z</published>
    <updated>2020-11-14T15:20:24.788Z</updated>
    
    <content type="html"><![CDATA[<p>如何保证一个对象只有一个实例并且易于访问呢？定义一个全局变量可以确保对象随时都可以被访问，但是不能防止我们实例化多个对象。一个更好的解决方法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。单例模式主要有五种实现方式，分别是饿汉模式、懒汉模式、双检锁（DCL）、静态内部类和枚举，下面分别展示了这几种模式的Java写法。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式确保某一个类只有一个实例，自行实例化并向整个系统提供这个实例，由它来提供全局访问的方法。单例模式有三个要点：一个类只能有一个实例；它必须自行创建这个实例；它必须自行向整个系统提供这个实例。</p><h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉模式基于类装载机制，可避免多线程的同步问题。饿汉模式的实例是在类加载的过程中被创建出来的，因此可以保证只会存在一份对象实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉模式最重要的是实现了Lazy Loading的效果，但是下面这种写法在多线程情况下不能正常工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h3><p>下面的示例引自<a href="http://blog.csdn.net/u013256816/article/details/50966882" target="_blank" rel="noopener">朱小厮的博客</a>，关于双检锁问题的根源在InfoQ的<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a>一文中有详细的介绍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockingSingleton</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// java中使用双重检查锁定机制,由于Java编译器和JIT的优化的原因系统无法保证我们期望的执行次序。  </span></span><br><span class="line">        <span class="comment">// 在java5.0修改了内存模型,使用volatile声明的变量可以强制屏蔽编译器和JIT的优化工作  </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckedLockingSingleton uniqueInstance;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckedLockingSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLockingSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        <span class="keyword">synchronized</span> (DoubleCheckedLockingSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                                        uniqueInstance = <span class="keyword">new</span> DoubleCheckedLockingSingleton();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> uniqueInstance;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类同样基于类装载机制来避免多线程的同步问题。它跟饿汉模式的区别在于，饿汉模式是Singleton类只要被加载就会马上实例化INSTANCE，而使用这种方式时，只有显式调用getInstance()时INSTANCE才会被实例化，从而达到Lazy Loading的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举不仅能避免多线程同步问题，而且也能有效防范反射和序列化攻击。另外，这种方式也可以实现多例，例如两例或三例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="如何防止反射攻击和序列化攻击"><a href="#如何防止反射攻击和序列化攻击" class="headerlink" title="如何防止反射攻击和序列化攻击"></a>如何防止反射攻击和序列化攻击</h2><p>下面是基于饿汉模式的一种单例实现，可以有效防范反射和序列化攻击，还能防范调用克隆方法产生新实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于防范反射攻击</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Singleton.singleton != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InstantiationError(<span class="string">"Creating of this object is not allowed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException(<span class="string">"Cloning of this class is not allowed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于防范序列化攻击</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要特点：<br>1、单例模式最主要的特点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。<br>2、单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源。<br>3、如果处理不当，系统中可能会因为反射攻击或其他原因（例如同时存在多个类加载器）而同时存在多个实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何保证一个对象只有一个实例并且易于访问呢？定义一个全局变量可以确保对象随时都可以被访问，但是不能防止我们实例化多个对象。一个更好的解决方法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。单例模式主要有五种实现方式，分别是饿汉模式、懒汉模式、双检锁（DCL）、静态内部类和枚举，下面分别展示了这几种模式的Java写法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://shenofusc.github.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
